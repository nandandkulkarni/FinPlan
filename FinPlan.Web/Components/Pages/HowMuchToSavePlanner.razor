@page "/howmuch-to-save-per-month"
@using System.Globalization
@using Microsoft.AspNetCore.Components.Forms
@using FinPlan.Shared.Services
@rendermode InteractiveServer

<style>
    .bucket-post { background-color: #ffecb3; }
    .bucket-trad { background-color: #cfeeff; }
    .bucket-roth { background-color: #e9dbff; }
    .bucket-total { background-color: #cfeccf; font-weight:600; }

    .table thead th { text-align: center; }
    .table tbody td { vertical-align: middle; }

    /* Header group bands matching bucket colors */
    /* Use more specific selectors and !important so Bootstrap doesn't override these */
    .table thead th.group-post { background-color: #ffecb3 !important; }
    .table thead th.group-trad { background-color: #cfeeff !important; }
    .table thead th.group-roth { background-color: #e9dbff !important; }
    .table thead th.group-total { background-color: #cfeccf !important; font-weight:600; }

    /* Ensure header cells inherit color and remove default white background */
    .table thead th { background: transparent !important; }
    .table thead th.group-post, .table thead th.group-trad, .table thead th.group-roth, .table thead th.group-total { color: #222 !important; }
    /* Also style the subheader cells so the colored band spans both header rows */
    .table thead th.sub-post { background-color: #ffecb3 !important; color: #222 !important; }
    .table thead th.sub-trad { background-color: #cfeeff !important; color: #222 !important; }
    .table thead th.sub-roth { background-color: #e9dbff !important; color: #222 !important; }
    .table thead th.sub-total { background-color: #cfeccf !important; color: #222 !important; font-weight:600; }

    /* Body cell bands - slightly lighter so header remains stronger */
    .table tbody td.bucket-post { background-color: #fff9ec !important; }
    .table tbody td.bucket-trad { background-color: #eaf9ff !important; }
    .table tbody td.bucket-roth { background-color: #f8f1ff !important; }
    .table tbody td.bucket-total { background-color: #eefbf0 !important; font-weight:600 !important; }

    /* Sub-header styling */
    .subhead { font-size: 0.85rem; font-weight:600; }
</style>

<h3>Retirement Savings Back‑Calculator</h3>

<div class="card p-3 mb-3">
    <EditForm Model="this" OnValidSubmit="Calculate">
        <div class="row g-2">
            <div class="col-md-2">
                <label>Current age</label>
                <InputNumber class="form-control" @bind-Value="CurrentAge" />
            </div>
            <div class="col-md-2">
                <label>Retirement age</label>
                <InputNumber class="form-control" @bind-Value="RetirementAge" />
            </div>
            <div class="col-md-4">
                <label>Target at retirement (nominal future $)</label>
                <InputNumber class="form-control" @bind-Value="TargetAmount" />
            </div>
            <div class="col-md-2">
                <label>Annual return % (nominal)</label>
                <InputNumber class="form-control" @bind-Value="AnnualReturnPercent" />
            </div>
            <div class="col-md-2">
                <label>Compounding</label>
                <div class="form-text">Monthly, deposits at start</div>
            </div>

            <div class="col-12"><hr /></div>

            <div class="col-md-4">
                <label><InputCheckbox @bind-Value="IncludePostTax" /> Post‑tax</label>
                <div class="form-text">Growth rate (annual %) for contributions</div>
                <InputNumber class="form-control form-control-sm" @bind-Value="PostTaxGrowthPercent" />
            </div>

            <div class="col-md-4">
                <label><InputCheckbox @bind-Value="IncludeTraditional" /> Traditional (pre‑tax)</label>
                <div class="form-text">Growth rate (annual %) for contributions</div>
                <InputNumber class="form-control form-control-sm" @bind-Value="TraditionalGrowthPercent" />
            </div>

            <div class="col-md-4">
                <label><InputCheckbox @bind-Value="IncludeRoth" /> Roth (post‑tax)</label>
                <div class="form-text">Growth rate (annual %) for contributions</div>
                <InputNumber class="form-control form-control-sm" @bind-Value="RothGrowthPercent" />
            </div>

            <div class="col-12"><hr /></div>

            <div class="col-12">
                <div class="card p-2 mb-2">
                    <div class="row g-2 align-items-end">
                        <div class="col-md-4">
                            <label>Ordinary tax rate %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="OrdinaryTaxPercent" />
                            <div class="form-text">Default applied to Traditional withdrawals and taxable ordinary income</div>
                        </div>
                        <div class="col-md-4">
                            <label>Long-term gains tax %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="LTGTaxPercent" />
                            <div class="form-text">Applied to qualified dividends & long-term gains</div>
                        </div>
                        <div class="col-md-4">
                            <label>Taxable income mix</label>
                            <select class="form-select form-select-sm" @bind="IncomeDistributionMode">
                                <option value="Mixed">Mixed (default)</option>
                                <option value="Dividends">Mostly Dividends</option>
                                <option value="LongTermGains">Mostly Long-Term Gains</option>
                                <option value="Interest">Mostly Interest/Short-Term</option>
                            </select>
                            <div class="form-text">Affects annual tax on taxable account growth</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-12">
                <button class="btn btn-sm btn-outline-secondary mb-2" type="button" @onclick="() => ShowAdvanced = !ShowAdvanced">
                    @(ShowAdvanced ? "Hide advanced settings" : "Show advanced settings")
                </button>

                @if (ShowAdvanced)
                {
                    <div class="card p-3 mb-3">
                        <h6>Advanced settings</h6>
                        <div class="row g-2">
                            <div class="col-md-3">
                                <label>Solver iterations</label>
                                <InputNumber class="form-control form-control-sm" @bind-Value="SolverIterations" />
                                <div class="form-text">Max iterations for numeric solver (higher -> more accurate, slower)</div>
                            </div>
                            <div class="col-md-3">
                                <label>Solver tolerance</label>
                                <InputNumber class="form-control form-control-sm" @bind-Value="SolverTolerance" />
                                <div class="form-text">Stopping tolerance for solver (in dollars)</div>
                            </div>
                            <div class="col-md-3">
                                <label>Use yearly grid as authoritative</label>
                                <div>
                                    <InputCheckbox @bind-Value="UseYearlyGridAsSource" /> <small class="text-muted">Use simulated grid totals for final amounts</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <label>Round intermediate</label>
                                <div>
                                    <InputCheckbox @bind-Value="RoundIntermediate" /> <small class="text-muted">Round intermediate values (affects accuracy)</small>
                                </div>
                            </div>
                        </div>
                     </div>
                 }
             </div>

            <div class="col-12">
                <div class="card p-2 mb-2">
                    <div class="row g-2 align-items-end">
                        <div class="col-md-4">
                            <label>Ordinary tax rate %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="OrdinaryTaxPercent" />
                            <div class="form-text">Default applied to Traditional withdrawals and taxable ordinary income</div>
                        </div>
                        <div class="col-md-4">
                            <label>Long-term gains tax %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="LTGTaxPercent" />
                            <div class="form-text">Applied to qualified dividends & long-term gains</div>
                        </div>
                        <div class="col-md-4">
                            <label>Taxable income mix</label>
                            <select class="form-select form-select-sm" @bind="IncomeDistributionMode">
                                <option value="Mixed">Mixed (default)</option>
                                <option value="Dividends">Mostly Dividends</option>
                                <option value="LongTermGains">Mostly Long-Term Gains</option>
                                <option value="Interest">Mostly Interest/Short-Term</option>
                            </select>
                            <div class="form-text">Affects annual tax on taxable account growth</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-12">
                <div class="card p-2 mb-2">
                    <div class="row g-2 align-items-end">
                        <div class="col-md-4">
                            <label>Ordinary tax rate %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="OrdinaryTaxPercent" />
                            <div class="form-text">Default applied to Traditional withdrawals and taxable ordinary income</div>
                        </div>
                        <div class="col-md-4">
                            <label>Long-term gains tax %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="LTGTaxPercent" />
                            <div class="form-text">Applied to qualified dividends & long-term gains</div>
                        </div>
                        <div class="col-md-4">
                            <label>Taxable income mix</label>
                            <select class="form-select form-select-sm" @bind="IncomeDistributionMode">
                                <option value="Mixed">Mixed (default)</option>
                                <option value="Dividends">Mostly Dividends</option>
                                <option value="LongTermGains">Mostly Long-Term Gains</option>
                                <option value="Interest">Mostly Interest/Short-Term</option>
                            </select>
                            <div class="form-text">Affects annual tax on taxable account growth</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-12">
                <div class="card p-2 mb-2">
                    <div class="row g-2 align-items-end">
                        <div class="col-md-4">
                            <label>Ordinary tax rate %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="OrdinaryTaxPercent" />
                            <div class="form-text">Default applied to Traditional withdrawals and taxable ordinary income</div>
                        </div>
                        <div class="col-md-4">
                            <label>Long-term gains tax %</label>
                            <InputNumber class="form-control form-control-sm" @bind-Value="LTGTaxPercent" />
                            <div class="form-text">Applied to qualified dividends & long-term gains</div>
                        </div>
                        <div class="col-md-4">
                            <label>Taxable income mix</label>
                            <select class="form-select form-select-sm" @bind="IncomeDistributionMode">
                                <option value="Mixed">Mixed (default)</option>
                                <option value="Dividends">Mostly Dividends</option>
                                <option value="LongTermGains">Mostly Long-Term Gains</option>
                                <option value="Interest">Mostly Interest/Short-Term</option>
                            </select>
                            <div class="form-text">Affects annual tax on taxable account growth</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-12 mt-2">
                <button class="btn btn-primary me-2" type="button" @onclick="Calculate">Calculate</button>
                <button class="btn btn-secondary" type="button" @onclick="Reset">Reset</button>
            </div>
        </div>
    </EditForm>
</div>

@if (HasCalculated)
{
    <div class="card p-3">
        <h5>Assumptions</h5>
        <p>
            Target is nominal future dollars at retirement. Monthly compounding, deposits at start of month.
            Annual return: @AnnualReturnPercent% • Horizon: @YearsUntilRetirement years (@Months months)
        </p>

        <h5>Results</h5>
        <table class="table table-sm">
            <thead>
                <tr>
                    <th>Bucket</th>
                    <th>Included</th>
                    <th>Allocation %</th>
                    <th>Annual growth % (contrib)</th>
                    <th>Initial monthly contribution</th>
                    <th>Projected FV (bucket)</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var r in BucketResults)
                {
                    <tr>
                        <td>@r.Name</td>
                        <td>@(r.Included ? "Yes" : "No")</td>
                        <td>@r.AllocationPercent.ToString("P0")</td>
                        <td>@r.AnnualGrowthPercent.ToString("P2")</td>
                        <td>@(r.Included ? FormatMoney(r.InitialMonthly) : "-")</td>
                        <td>@(r.Included ? FormatMoney(r.ProjectedFV) : "-")</td>
                    </tr>
                }
                <tr class="table-primary">
                    <th colspan="4">Total initial monthly</th>
                    <th>@FormatMoney(TotalInitialMonthly)</th>
                    <th>@FormatMoney(GetFinalProjectedTotal())</th>
                </tr>
            </tbody>
        </table>

        <h5 class="mt-4">Yearly Projection Grid</h5>
        <p>
            Detailed projection of each bucket's growth, principal, and estimated taxes (for taxable bucket) over time.
        </p>
        <table class="table table-sm table-bordered">
            <thead>
                <!-- Top header row: colored group bands -->
                <tr>
                    <th rowspan="2">Year</th>
                    <th rowspan="2">Age</th>
                    <th colspan="5" class="group-post">Post‑tax (taxable)</th>
                    <th colspan="5" class="group-trad">Traditional (pre‑tax)</th>
                    <th colspan="4" class="group-roth">Roth (post‑tax)</th>
                    <th colspan="5" class="group-total">Totals</th>
                </tr>

                <!-- Second header row: descriptive column labels -->
                <tr>
                    <!-- Post-tax columns -->
                    <th class="subhead">Principal</th>
                    <th class="subhead">Growth</th>
                    <th class="subhead">No‑tax balance</th>
                    <th class="subhead">Taxes</th>
                    <th class="subhead sub-post">Ending balance</th>

                    <!-- Traditional columns: pre-tax + growth + taxes (none here) + ending + after-tax -->
                    <th class="subhead sub-trad">Principal</th>
                    <th class="subhead sub-trad">Growth</th>
                    <th class="subhead sub-trad">Taxes</th>
                    <th class="subhead sub-trad">Ending (pre‑tax)</th>
                    <th class="subhead sub-trad">Ending (after‑tax)</th>

                    <!-- Roth columns -->
                    <th class="subhead sub-roth">Principal</th>
                    <th class="subhead sub-roth">Growth</th>
                    <th class="subhead sub-roth">Taxes</th>
                    <th class="subhead sub-roth">Ending balance</th>

                    <!-- Totals: principal, growth, combined pre-tax, taxes, ending (after‑tax) -->
                    <th class="subhead sub-total">Principal</th>
                    <th class="subhead sub-total">Growth</th>
                    <th class="subhead sub-total">Combined pre‑tax</th>
                    <th class="subhead sub-total">Taxes</th>
                    <th class="subhead sub-total">Ending (after‑tax)</th>
                </tr>
            </thead>
            <tbody>
                @{ var ordRate = OrdinaryTaxPercent / 100m; }
                @foreach (var r in YearlyGrid)
                {
                    <tr>
                        <td>@r.Year</td>
                        <td>@r.Age</td>

                        <td class="text-end bucket-post" style="background-color:#fff9ec;">@FormatMoney(r.PostTaxPrincipal)</td>
                        <td class="text-end bucket-post" style="background-color:#fff9ec;">@FormatMoney(r.PostTaxGrowth)</td>
                        <td class="text-end bucket-post" style="background-color:#fff9ec;">@FormatMoney(r.PostTaxPreTaxBalance)</td>
                        <td class="text-end bucket-post" style="background-color:#fff9ec;">@FormatMoney(r.PostTaxTaxes)</td>
                        <td class="text-end bucket-post" style="background-color:#fff9ec;">@FormatMoney(r.PostTaxBalance)</td>

                        <td class="text-end bucket-trad" style="background-color:#eaf9ff;">@FormatMoney(r.TraditionalPrincipal)</td>
                        <td class="text-end bucket-trad" style="background-color:#eaf9ff;">@FormatMoney(r.TraditionalGrowth)</td>
                        <td class="text-end bucket-trad" style="background-color:#eaf9ff;">@FormatMoney(r.TraditionalTaxes)</td>
                        <td class="text-end bucket-trad" style="background-color:#eaf9ff;">@FormatMoney(r.TraditionalBalance)</td>
                        <td class="text-end bucket-trad" style="background-color:#eaf9ff;">@FormatMoney(Math.Round(r.TraditionalBalance * (1m - ordRate), 2))</td>

                        <td class="text-end bucket-roth" style="background-color:#f8f1ff;">@FormatMoney(r.RothPrincipal)</td>
                        <td class="text-end bucket-roth" style="background-color:#f8f1ff;">@FormatMoney(r.RothGrowth)</td>
                        <td class="text-end bucket-roth" style="background-color:#f8f1ff;">@FormatMoney(r.RothTaxes)</td>
                        <td class="text-end bucket-roth" style="background-color:#f8f1ff;">@FormatMoney(r.RothBalance)</td>

                        <td class="text-end bucket-total" style="background-color:#eefbf0;">@FormatMoney(r.PostTaxPrincipal + r.TraditionalPrincipal + r.RothPrincipal)</td>
                        <td class="text-end bucket-total" style="background-color:#eefbf0;">@FormatMoney(r.PostTaxGrowth + r.TraditionalGrowth + r.RothGrowth)</td>
                        @* Show combined pre-tax balances column for reference *@
                        <td class="text-end bucket-total" style="background-color:#eefbf0;">@FormatMoney(r.PostTaxPreTaxBalance + r.TraditionalBalance + r.RothBalance)</td>
                        <td class="text-end bucket-total" style="background-color:#eefbf0;">@FormatMoney(r.PostTaxTaxes + r.TraditionalTaxes + r.RothTaxes)</td>
                        @* Display total in post-tax (withdrawal) basis: convert Traditional to after-tax *@
                        @{ var totalAfterTax = r.PostTaxBalance + r.TraditionalBalance * (1m - ordRate) + r.RothBalance; }
                        <td class="text-end bucket-total" style="background-color:#eefbf0;">@FormatMoney(Math.Round(totalAfterTax,2))</td>
                     </tr>
                 }
             </tbody>
         </table>
     </div>
 }

@code {
    // Inputs
    public int CurrentAge { get; set; } = 35;
    public int RetirementAge { get; set; } = 67;
    public decimal TargetAmount { get; set; } = 1000000m;
    public decimal AnnualReturnPercent { get; set; } = 6m;

    public bool IncludePostTax { get; set; } = true;
    public bool IncludeTraditional { get; set; } = true;
    public bool IncludeRoth { get; set; } = false;

    public decimal PostTaxGrowthPercent { get; set; } = 0m;
    public decimal TraditionalGrowthPercent { get; set; } = 0m;
    public decimal RothGrowthPercent { get; set; } = 0m;

    // Tax inputs (user-editable)
    public decimal OrdinaryTaxPercent { get; set; } = 24m; // default 24%
    public decimal LTGTaxPercent { get; set; } = 15m; // default 15%
    public string IncomeDistributionMode { get; set; } = "Mixed"; // Mixed, Dividends, LongTermGains, Interest

    public AllocationModes AllocationMode { get; set; } = AllocationModes.Equal;
    public decimal PostTaxPct { get; set; } = 0m;
    public decimal TraditionalPct { get; set; } = 0m;
    public decimal RothPct { get; set; } = 0m;

    // Advanced settings
    public bool ShowAdvanced { get; set; } = false;
    public int SolverIterations { get; set; } = 120;
    public decimal SolverTolerance { get; set; } = 0.5m; // in dollars
    public bool UseYearlyGridAsSource { get; set; } = true;
    public bool RoundIntermediate { get; set; } = false;
    // Diagnostics
    public decimal LastSolverError { get; set; } = 0m;

    // Derived / results
    bool HasCalculated = false;
    int YearsUntilRetirement;
    int Months;
    int n;
    decimal MonthlyRate;

    List<BucketResult> BucketResults = new();

    decimal TotalInitialMonthly = 0m;

    public enum AllocationModes { Equal, Custom }

    class BucketResult
    {
        public string Name { get; set; } = "";
        public bool Included { get; set; }
        public decimal AllocationPercent { get; set; }
        public decimal AnnualGrowthPercent { get; set; }
        public decimal InitialMonthly { get; set; }
        // Projected future value from solver/simpler math
        public decimal ProjectedFV { get; set; }
        // Projected future value from full yearly grid simulation (authoritative)
        public decimal ProjectedFVFromGrid { get; set; }
    }

    // Yearly grid row combining all three buckets
    class YearlyGridRow
    {
        public int Year { get; set; }
        public int Age { get; set; }

        public decimal PostTaxPrincipal { get; set; }
        public decimal PostTaxGrowth { get; set; }
        public decimal PostTaxTaxes { get; set; }
        public decimal PostTaxPreTaxBalance { get; set; }
        public decimal PostTaxBalance { get; set; }

        public decimal TraditionalPrincipal { get; set; }
        public decimal TraditionalGrowth { get; set; }
        public decimal TraditionalTaxes { get; set; }
        public decimal TraditionalBalance { get; set; }

        public decimal RothPrincipal { get; set; }
        public decimal RothGrowth { get; set; }
        public decimal RothTaxes { get; set; }
        public decimal RothBalance { get; set; }

        public decimal TotalEndOfYear => PostTaxBalance + TraditionalBalance + RothBalance;
    }

    List<YearlyGridRow> YearlyGrid = new();

    // Tax assumptions used for taxable bucket (simple approximation)
    const decimal DEFAULT_ORDINARY_TAX = 0.24m;
    const decimal DEFAULT_LTG_TAX = 0.15m;
    // Default income distribution (MixedInvestment) used to split taxable interest
    readonly (decimal q, decimal nonq, decimal lt, decimal st) DEFAULT_INCOME_DISTRIBUTION = (0.25m, 0.25m, 0.40m, 0.10m);

    void Reset()
    {
        CurrentAge = 35;
        RetirementAge = 67;
        TargetAmount = 1000000m;
        AnnualReturnPercent = 6m;
        IncludePostTax = true;
        IncludeTraditional = true;
        IncludeRoth = false;
        PostTaxGrowthPercent = TraditionalGrowthPercent = RothGrowthPercent = 0m;
        AllocationMode = AllocationModes.Equal;
        PostTaxPct = TraditionalPct = RothPct = 0m;
        OrdinaryTaxPercent = 24;
        LTGTaxPercent = 15;
        IncomeDistributionMode = "Mixed";
        HasCalculated = false;
        BucketResults.Clear();
        TotalInitialMonthly = 0m;
        YearlyGrid.Clear();
    }

    private async Task Calculate()
    {
        try
        {
            HasCalculated = false;
            BucketResults.Clear();
            TotalInitialMonthly = 0m;
            YearlyGrid.Clear();

            if (RetirementAge <= CurrentAge || TargetAmount <= 0)
            {
                HasCalculated = true;
                return;
            }

            YearsUntilRetirement = RetirementAge - CurrentAge;
            Months = YearsUntilRetirement * 12;
            n = Months;
            MonthlyRate = (AnnualReturnPercent / 100m) / 12m;

            // identify included buckets
            var included = new List<string>();
            if (IncludePostTax) included.Add("Post‑tax");
            if (IncludeTraditional) included.Add("Traditional");
            if (IncludeRoth) included.Add("Roth");

            if (!included.Any())
            {
                HasCalculated = true;
                return;
            }

            // allocation percents
            var alloc = new Dictionary<string, decimal>();
            if (AllocationMode == AllocationModes.Equal)
            {
                var equal = 1m / included.Count;
                foreach (var k in included) alloc[k] = equal;
            }
            else
            {
                // custom: use provided percents but ignore unchecked buckets
                var sum = 0m;
                if (IncludePostTax) sum += PostTaxPct;
                if (IncludeTraditional) sum += TraditionalPct;
                if (IncludeRoth) sum += RothPct;
                if (sum <= 0) // fallback to equal
                {
                    var equal = 1m / included.Count;
                    foreach (var k in included) alloc[k] = equal;
                }
                else
                {
                    if (IncludePostTax) alloc["Post‑tax"] = PostTaxPct / sum;
                    if (IncludeTraditional) alloc["Traditional"] = TraditionalPct / sum;
                    if (IncludeRoth) alloc["Roth"] = RothPct / sum;
                }
            }

            // compute per bucket
            var buckets = new[]
            {
                new { Name = "Post‑tax", Included = IncludePostTax, AnnualGrowth = PostTaxGrowthPercent },
                new { Name = "Traditional", Included = IncludeTraditional, AnnualGrowth = TraditionalGrowthPercent },
                new { Name = "Roth", Included = IncludeRoth, AnnualGrowth = RothGrowthPercent }
            };

            foreach (var b in buckets)
            {
                var br = new BucketResult { Name = b.Name, Included = b.Included, AnnualGrowthPercent = b.AnnualGrowth / 100m };
                if (!b.Included)
                {
                    BucketResults.Add(br);
                    continue;
                }

                var allocPct = alloc.ContainsKey(b.Name) ? alloc[b.Name] : 0m;
                br.AllocationPercent = allocPct;
                var requiredFuture = TargetAmount * allocPct;

                // compute initial monthly PMT for growing annuity (payments at start of month)
                var gm = AnnualToMonthlyGrowth(b.AnnualGrowth / 100m);

                // Use user-provided tax inputs
                var ordinaryRate = OrdinaryTaxPercent / 100m;
                var ltgRate = LTGTaxPercent / 100m;
                var dist = GetIncomeDistributionFromMode();

                if (b.Name == "Traditional")
                {
                    // gross-up required future to pre-tax value assuming full ordinary tax on withdrawal
                    var pretaxRequired = ordinaryRate >= 1m ? requiredFuture : requiredFuture / (1m - ordinaryRate);
                    br.InitialMonthly = ComputeInitialMonthly(pretaxRequired, MonthlyRate, gm, n);
                    var pretaxFV = ComputeProjectedFVFromGrowingPayments(br.InitialMonthly, MonthlyRate, gm, n);
                    br.ProjectedFV = Math.Round(pretaxFV * (1m - ordinaryRate), 2);
                    // store solver value also
                    br.ProjectedFVFromGrid = 0m;
                }
                else if (b.Name == "Roth")
                {
                    // Roth is post-tax at contribution, no tax at withdrawal
                    br.InitialMonthly = ComputeInitialMonthly(requiredFuture, MonthlyRate, gm, n);
                    br.ProjectedFV = ComputeProjectedFVFromGrowingPayments(br.InitialMonthly, MonthlyRate, gm, n);
                    br.ProjectedFVFromGrid = 0m;
                }
                else // Post-tax (taxable)
                {
                    // Solve numerically for initial monthly payment that yields requiredFuture after annual taxes
                    br.InitialMonthly = TaxableSimulator.SolveInitialMonthlyForPostTax(requiredFuture, MonthlyRate, gm, n, ordinaryRate, ltgRate, dist, SolverIterations, SolverTolerance, RoundIntermediate);
                    br.ProjectedFV = TaxableSimulator.SimulatePostTaxFinalFromPmt(br.InitialMonthly, MonthlyRate, gm, n, ordinaryRate, ltgRate, dist, RoundIntermediate);
                    br.ProjectedFVFromGrid = 0m;
                }

                TotalInitialMonthly += br.InitialMonthly;
                BucketResults.Add(br);
            }

            // Build yearly grid by simulating each bucket's payments and growth
            BuildYearlyGrid();

            // After building grid, fill BucketResults.ProjectedFVFromGrid from YearlyGrid last row
            if (YearlyGrid.Any())
            {
                var last = YearlyGrid.Last();
                // apply tax adjustments for authoritative projected FV from grid
                var ordinaryRate = OrdinaryTaxPercent / 100m;
                foreach (var br in BucketResults)
                {
                    if (br.Name == "Post‑tax") br.ProjectedFVFromGrid = last.PostTaxBalance;
                    if (br.Name == "Traditional") br.ProjectedFVFromGrid = Math.Round(last.TraditionalBalance * (1m - ordinaryRate), 2);
                    if (br.Name == "Roth") br.ProjectedFVFromGrid = last.RothBalance;
                }

                // Diagnostic logging
                try
                {
                    Console.WriteLine("--- HowMuchToSavePlanner diagnostics ---");
                    Console.WriteLine($"TargetAmount={TargetAmount}, Years={YearsUntilRetirement}, MonthlyRate={MonthlyRate}");
                    foreach (var brr in BucketResults)
                    {
                        Console.WriteLine($"Bucket {brr.Name}: InitialMonthly={brr.InitialMonthly}, ProjectedFV(solver)={brr.ProjectedFV}, ProjectedFV(grid)={brr.ProjectedFVFromGrid}");
                    }
                    Console.WriteLine($"YearlyGrid final total: {YearlyGrid.Last().TotalEndOfYear}");
                }
                catch { }
            }

            // Optionally replace displayed ProjectedFV with grid values
            if (UseYearlyGridAsSource && YearlyGrid.Any())
            {
                foreach (var br in BucketResults)
                {
                    br.ProjectedFV = br.ProjectedFVFromGrid;
                }
            }

            HasCalculated = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Calculate error: {ex}");
        }
    }

    private void BuildYearlyGrid()
    {
        if (BucketResults == null || !BucketResults.Any()) return;

        // For each bucket prepare simulation state
        var post = BucketResults.FirstOrDefault(x => x.Name == "Post‑tax");
        var trad = BucketResults.FirstOrDefault(x => x.Name == "Traditional");
        var roth = BucketResults.FirstOrDefault(x => x.Name == "Roth");

        decimal postBal = 0m, tradBal = 0m, rothBal = 0m;
        decimal postNoTaxBal = 0m; // separate balance if no taxes applied
        decimal postPmt0 = post?.InitialMonthly ?? 0m;
        decimal tradPmt0 = trad?.InitialMonthly ?? 0m;
        decimal rothPmt0 = roth?.InitialMonthly ?? 0m;
        decimal postGm = AnnualToMonthlyGrowth((post?.AnnualGrowthPercent ?? 0m));
        decimal tradGm = AnnualToMonthlyGrowth((trad?.AnnualGrowthPercent ?? 0m));
        decimal rohGm = AnnualToMonthlyGrowth((roth?.AnnualGrowthPercent ?? 0m));

        // Prepare tax/distribution using user inputs
        var dist = GetIncomeDistributionFromMode();
        var ordinaryRate = OrdinaryTaxPercent / 100m;
        var ltgRate = LTGTaxPercent / 100m;

        int totalMonths = n;
        int monthIndex = 0; // 0-based

        for (int year = 1; year <= YearsUntilRetirement; year++)
        {
            var row = new YearlyGridRow { Year = year, Age = CurrentAge + year };
            decimal postYearPrincipal = 0m, postYearGrowth = 0m, postYearTaxes = 0m;
            decimal tradYearPrincipal = 0m, tradYearGrowth = 0m, tradYearTaxes = 0m;
            decimal rothYearPrincipal = 0m, rothYearGrowth = 0m, rothYearTaxes = 0m;

            for (int m = 1; m <= 12 && monthIndex < totalMonths; m++, monthIndex++)
            {
                int mAbs = monthIndex; // 0-based month count
                // payment grows by gm per month: pmt = pmt0 * (1+gm)^mAbs
                if (post != null && post.Included)
                {
                    var p = postPmt0 * DecimalPow(1m + postGm, mAbs);
                    postYearPrincipal += p;
                    // deposit at start of month
                    postBal += p;
                    postNoTaxBal += p;
                    // interest
                    var i = postBal * MonthlyRate;
                    postYearGrowth += i;
                    postBal += i;
                    // interest applied to no-tax balance as well
                    var iNoTax = postNoTaxBal * MonthlyRate;
                    postNoTaxBal += iNoTax;
                }

                if (trad != null && trad.Included)
                {
                    var p = tradPmt0 * DecimalPow(1m + tradGm, mAbs);
                    tradYearPrincipal += p;
                    tradBal += p;
                    var i = tradBal * MonthlyRate;
                    tradYearGrowth += i;
                    tradBal += i;
                }

                if (roth != null && roth.Included)
                {
                    var p = rothPmt0 * DecimalPow(1m + rohGm, mAbs);
                    rothYearPrincipal += p;
                    rothBal += p;
                    var i = rothBal * MonthlyRate;
                    rothYearGrowth += i;
                    rothBal += i;
                }
            }

            // capture no-tax cumulative balance (what taxable bucket would be if taxes were never applied)
            var postPreTaxBalance = postNoTaxBal;

            // Taxes for taxable (post-tax) bucket - use user inputs
            if (post != null && post.Included)
            {
                var qual = postYearGrowth * dist.q;
                var nonq = postYearGrowth * dist.nonq;
                var lt = postYearGrowth * dist.lt;
                var st = postYearGrowth * dist.st;
                var taxes = qual * ltgRate + (nonq + st) * ordinaryRate + lt * ltgRate;
                postYearTaxes = taxes;
                postBal -= taxes;
            }

            // store no-tax balance (what the taxable bucket would be if no taxes were ever applied)
            row.PostTaxPreTaxBalance = Math.Round(postPreTaxBalance, 2);

            // traditional and roth taxes assumed zero during accumulation

            row.PostTaxPrincipal = Math.Round(postYearPrincipal, 2);
            row.PostTaxGrowth = Math.Round(postYearGrowth, 2);
            row.PostTaxTaxes = Math.Round(postYearTaxes, 2);
            row.PostTaxBalance = Math.Round(postBal, 2);

            row.TraditionalPrincipal = Math.Round(tradYearPrincipal, 2);
            row.TraditionalGrowth = Math.Round(tradYearGrowth, 2);
            row.TraditionalTaxes = 0m;
            row.TraditionalBalance = Math.Round(tradBal, 2);

            row.RothPrincipal = Math.Round(rothYearPrincipal, 2);
            row.RothGrowth = Math.Round(rothYearGrowth, 2);
            row.RothTaxes = 0m;
            row.RothBalance = Math.Round(rothBal, 2);

            YearlyGrid.Add(row);
        }
    }

    private decimal GetFinalProjectedTotal()
    {
        var sum = BucketResults.Where(x => x.Included).Sum(x => x.ProjectedFV);
        if (sum == 0m && YearlyGrid.Any())
            return Math.Round(YearlyGrid.Last().TotalEndOfYear, 2);
        return Math.Round(sum, 2);
    }

    // convert annual growth rate to equivalent monthly growth
    private decimal AnnualToMonthlyGrowth(decimal annual)
    {
        if (annual == 0m) return 0m;
        var gm = (decimal)(Math.Pow((double)(1m + annual), 1.0 / 12.0) - 1.0);
        return gm;
    }

    // Compute initial monthly payment (month 1 payment) for an annuity-due with growth gm per month
    private decimal ComputeInitialMonthly(decimal futureTarget, decimal r, decimal gm, int periods)
    {
        if (periods <= 0) return 0m;

        const decimal EPS = 1e-12m;
        // handle special cases
        if (Math.Abs((double)(r - gm)) < 1e-12)
        {
            // r == gm
            var G = periods * (1m + r);
            return G <= 0 ? 0m : futureTarget / G;
        }

        // compute (1+r)^n and (1+gm)^n
        var onePlusRpowN = DecimalPow(1m + r, periods);
        var onePlusGmpowN = DecimalPow(1m + gm, periods);

        // G = [ (1+r)^n - (1+gm)^n ] / (r - gm) * (1+r)
        var denom = r - gm;
        // guard denom close to zero handled above
        var Gfactor = ((onePlusRpowN - onePlusGmpowN) / denom) * (1m + r);
        return Gfactor == 0m ? 0m : futureTarget / Gfactor;
    }

    // Compute projected future value produced by a growing payment stream starting with pmt0 (annuity due)
    private decimal ComputeProjectedFVFromGrowingPayments(decimal pmt0, decimal r, decimal gm, int periods)
    {
        if (periods <= 0) return 0m;
        if (pmt0 == 0m) return 0m;

        if (Math.Abs((double)(r - gm)) < 1e-12)
        {
            var G = periods * (1m + r);
            return pmt0 * G;
        }

        var onePlusRpowN = DecimalPow(1m + r, periods);
        var onePlusGmpowN = DecimalPow(1m + gm, periods);
        var denom = r - gm;
        var Gfactor = ((onePlusRpowN - onePlusGmpowN) / denom) * (1m + r);
        return pmt0 * Gfactor;
    }

    // Decimal power helper for integer exponent >= 0
    private decimal DecimalPow(decimal x, int pow)
    {
        if (pow == 0) return 1m;
        double dx = (double)x;
        double r = Math.Pow(dx, pow);
        return (decimal)r;
    }

    string FormatMoney(decimal v) => v.ToString("C0", CultureInfo.CurrentCulture);

    private (decimal q, decimal nonq, decimal lt, decimal st) GetIncomeDistributionFromMode()
    {
        return IncomeDistributionMode switch
        {
            "Dividends" => (0.60m, 0.20m, 0.15m, 0.05m),
            "LongTermGains" => (0.15m, 0.10m, 0.70m, 0.05m),
            "Interest" => (0.05m, 0.65m, 0.10m, 0.20m),
            _ => (0.25m, 0.25m, 0.40m, 0.10m),
        };
    }

    private decimal SimulatePostTaxFinalFromPmt(decimal pmt0, decimal monthlyRate, decimal gm, int periods, decimal ordinaryRate, decimal ltgRate, (decimal q, decimal nonq, decimal lt, decimal st) dist, bool roundIntermediate = false)
    {
        if (periods <= 0) return 0m;
        decimal bal = 0m;
        int monthIndex = 0;

        while (monthIndex < periods)
        {
            decimal yearGrowth = 0m;
            for (int m = 0; m < 12 && monthIndex < periods; m++, monthIndex++)
            {
                var payment = pmt0 * DecimalPow(1m + gm, monthIndex);
                bal += payment;
                if (roundIntermediate) bal = Math.Round(bal, 8);
                var interest = bal * monthlyRate;
                yearGrowth += interest;
                bal += interest;
                if (roundIntermediate) bal = Math.Round(bal, 8);
            }

            var qual = yearGrowth * dist.q;
            var nonq = yearGrowth * dist.nonq;
            var lt = yearGrowth * dist.lt;
            var st = yearGrowth * dist.st;
            var taxes = qual * ltgRate + (nonq + st) * ordinaryRate + lt * ltgRate;
            if (roundIntermediate) taxes = Math.Round(taxes, 8);
            bal -= taxes;
            if (roundIntermediate) bal = Math.Round(bal, 8);
        }

        return Math.Round(bal, 2);
    }

    private decimal SolveInitialMonthlyForPostTax(decimal targetNet, decimal monthlyRate, decimal gm, int periods, decimal ordinaryRate, decimal ltgRate, (decimal q, decimal nonq, decimal lt, decimal st) dist, int maxIterations, decimal tolerance)
     {
         if (targetNet <= 0m || periods <= 0) return 0m;
 
         decimal low = 0m;
         decimal high = Math.Max(100m, targetNet / periods); // heuristic
 
         for (int expand = 0; expand < 60; expand++)
         {
             var testNet = SimulatePostTaxFinalFromPmt(high, monthlyRate, gm, periods, ordinaryRate, ltgRate, dist, RoundIntermediate);
             if (testNet >= targetNet) break;
             high *= 2m;
         }
 
         // reset diagnostics
         LastSolverError = 0m;
 
         decimal result = 0m;
         for (int iter = 0; iter < maxIterations; iter++)
         {
             var mid = (low + high) / 2m;
             var net = SimulatePostTaxFinalFromPmt(mid, monthlyRate, gm, periods, ordinaryRate, ltgRate, dist, RoundIntermediate);
             if (Math.Abs((double)(net - targetNet)) < (double)tolerance)
             {
                 result = mid;
                 // store solver diagnostic
                 LastSolverError = Math.Round(net - targetNet, 6);
                 break;
             }
             if (net < targetNet) low = mid; else high = mid;
             result = mid;
         }
 
         // return result with higher precision (avoid rounding to cents here)
         return Math.Round(result, 6);
     }
}