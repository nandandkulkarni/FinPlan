@page "/howmuch-to-save-per-month"
@using System.Globalization
@using Microsoft.AspNetCore.Components.Forms
@rendermode InteractiveServer

<style>
    .bucket-post { background-color: #fff8e1; }
    .bucket-trad { background-color: #e8f7ff; }
    .bucket-roth { background-color: #f7f0ff; }
    .bucket-total { background-color: #e9fbe9; font-weight:600; }

    .table thead th { text-align: center; }
    .table tbody td { vertical-align: middle; }
</style>

<h3>Retirement Savings Back‑Calculator</h3>

<div class="card p-3 mb-3">
    <EditForm Model="this" OnValidSubmit="Calculate">
        <div class="row g-2">
            <div class="col-md-2">
                <label>Current age</label>
                <InputNumber class="form-control" @bind-Value="CurrentAge" />
            </div>
            <div class="col-md-2">
                <label>Retirement age</label>
                <InputNumber class="form-control" @bind-Value="RetirementAge" />
            </div>
            <div class="col-md-4">
                <label>Target at retirement (nominal future $)</label>
                <InputNumber class="form-control" @bind-Value="TargetAmount" />
            </div>
            <div class="col-md-2">
                <label>Annual return % (nominal)</label>
                <InputNumber class="form-control" @bind-Value="AnnualReturnPercent" />
            </div>
            <div class="col-md-2">
                <label>Compounding</label>
                <div class="form-text">Monthly, deposits at start</div>
            </div>

            <div class="col-12"><hr /></div>

            <div class="col-md-4">
                <label><InputCheckbox @bind-Value="IncludePostTax" /> Post‑tax</label>
                <div class="form-text">Growth rate (annual %) for contributions</div>
                <InputNumber class="form-control form-control-sm" @bind-Value="PostTaxGrowthPercent" />
            </div>

            <div class="col-md-4">
                <label><InputCheckbox @bind-Value="IncludeTraditional" /> Traditional (pre‑tax)</label>
                <div class="form-text">Growth rate (annual %) for contributions</div>
                <InputNumber class="form-control form-control-sm" @bind-Value="TraditionalGrowthPercent" />
            </div>

            <div class="col-md-4">
                <label><InputCheckbox @bind-Value="IncludeRoth" /> Roth (post‑tax)</label>
                <div class="form-text">Growth rate (annual %) for contributions</div>
                <InputNumber class="form-control form-control-sm" @bind-Value="RothGrowthPercent" />
            </div>

            <div class="col-12">
                <label>Allocation mode</label>
                <InputRadioGroup @bind-Value="AllocationMode">
                    <label class="me-3"><InputRadio Value="@AllocationModes.Equal" /> Equal split</label>
                    <label class="ms-3"><InputRadio Value="@AllocationModes.Custom" /> Custom %</label>
                </InputRadioGroup>
            </div>

            @if (AllocationMode == AllocationModes.Custom)
            {
                <div class="col-md-4">
                    <label>Post‑tax %</label>
                    <InputNumber class="form-control" @bind-Value="PostTaxPct" />
                </div>
                <div class="col-md-4">
                    <label>Traditional %</label>
                    <InputNumber class="form-control" @bind-Value="TraditionalPct" />
                </div>
                <div class="col-md-4">
                    <label>Roth %</label>
                    <InputNumber class="form-control" @bind-Value="RothPct" />
                </div>
                <div class="col-12">
                    <small class="text-muted">Percents must sum to 100 across included buckets (unchecked buckets ignored).</small>
                </div>
            }

            <div class="col-12 mt-2">
                <button class="btn btn-primary me-2" type="button" @onclick="Calculate">Calculate</button>
                <button class="btn btn-secondary" type="button" @onclick="Reset">Reset</button>
            </div>
        </div>
    </EditForm>
</div>

@if (HasCalculated)
{
    <div class="card p-3">
        <h5>Assumptions</h5>
        <p>
            Target is nominal future dollars at retirement. Monthly compounding, deposits at start of month.
            Annual return: @AnnualReturnPercent% • Horizon: @YearsUntilRetirement years (@Months months)
        </p>

        <h5>Results</h5>
        <table class="table table-sm">
            <thead>
                <tr>
                    <th>Bucket</th>
                    <th>Included</th>
                    <th>Allocation %</th>
                    <th>Annual growth % (contrib)</th>
                    <th>Initial monthly contribution</th>
                    <th>Projected FV (bucket)</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var r in BucketResults)
                {
                    <tr>
                        <td>@r.Name</td>
                        <td>@(r.Included ? "Yes" : "No")</td>
                        <td>@r.AllocationPercent.ToString("P0")</td>
                        <td>@r.AnnualGrowthPercent.ToString("P2")</td>
                        <td>@(r.Included ? FormatMoney(r.InitialMonthly) : "-")</td>
                        <td>@(r.Included ? FormatMoney(r.ProjectedFV) : "-")</td>
                    </tr>
                }
                <tr class="table-primary">
                    <th colspan="4">Total initial monthly</th>
                    <th>@FormatMoney(TotalInitialMonthly)</th>
                    <th>@FormatMoney(GetFinalProjectedTotal())</th>
                </tr>
            </tbody>
        </table>

        <h5 class="mt-4">Yearly Projection Grid</h5>
        <p>
            Detailed projection of each bucket's growth, principal, and estimated taxes (for taxable bucket) over time.
        </p>
        <table class="table table-sm table-bordered">
            <thead>
                <tr>
                    <th>Year</th>
                    <th>Age</th>
                    <th colspan="5" class="text-center">Post‑tax</th>
                    <th colspan="4" class="text-center">Traditional</th>
                    <th colspan="4" class="text-center">Roth</th>
                    <th colspan="5" class="text-center">Total</th>
                </tr>
                <tr>
                    <th></th>
                    <th></th>
                    <th>Principal</th>
                    <th>Growth</th>
                    <th>No‑tax balance</th>
                    <th>Taxes</th>
                    <th>Ending Balance</th>
                    <th>Principal</th>
                    <th>Growth</th>
                    <th>Taxes</th>
                    <th>Ending Balance</th>
                    <th>Principal</th>
                    <th>Growth</th>
                    <th>Taxes</th>
                    <th>Ending Balance</th>
                    <th>Principal</th>
                    <th>Growth</th>
                    <th>No‑tax balance</th>
                    <th>Taxes</th>
                    <th>Ending Balance</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var r in YearlyGrid)
                {
                    <tr>
                        <td>@r.Year</td>
                        <td>@r.Age</td>

                        <td class="text-end bucket-post">@FormatMoney(r.PostTaxPrincipal)</td>
                        <td class="text-end bucket-post">@FormatMoney(r.PostTaxGrowth)</td>
                        <td class="text-end bucket-post">@FormatMoney(r.PostTaxPreTaxBalance)</td>
                        <td class="text-end bucket-post">@FormatMoney(r.PostTaxTaxes)</td>
                        <td class="text-end bucket-post">@FormatMoney(r.PostTaxBalance)</td>

                        <td class="text-end bucket-trad">@FormatMoney(r.TraditionalPrincipal)</td>
                        <td class="text-end bucket-trad">@FormatMoney(r.TraditionalGrowth)</td>
                        <td class="text-end bucket-trad">@FormatMoney(r.TraditionalTaxes)</td>
                        <td class="text-end bucket-trad">@FormatMoney(r.TraditionalBalance)</td>

                        <td class="text-end bucket-roth">@FormatMoney(r.RothPrincipal)</td>
                        <td class="text-end bucket-roth">@FormatMoney(r.RothGrowth)</td>
                        <td class="text-end bucket-roth">@FormatMoney(r.RothTaxes)</td>
                        <td class="text-end bucket-roth">@FormatMoney(r.RothBalance)</td>

                        <td class="text-end bucket-total">@FormatMoney(r.PostTaxPrincipal + r.TraditionalPrincipal + r.RothPrincipal)</td>
                        <td class="text-end bucket-total">@FormatMoney(r.PostTaxGrowth + r.TraditionalGrowth + r.RothGrowth)</td>
                        <td class="text-end bucket-total">@FormatMoney(r.PostTaxPreTaxBalance + r.TraditionalBalance + r.RothBalance)</td>
                        <td class="text-end bucket-total">@FormatMoney(r.PostTaxTaxes + r.TraditionalTaxes + r.RothTaxes)</td>
                        <td class="text-end bucket-total">@FormatMoney(r.TotalEndOfYear)</td>
                     </tr>
                 }
             </tbody>
         </table>
     </div>
 }

@code {
    // Inputs
    public int CurrentAge { get; set; } = 35;
    public int RetirementAge { get; set; } = 67;
    public decimal TargetAmount { get; set; } = 1000000m;
    public decimal AnnualReturnPercent { get; set; } = 6m;

    public bool IncludePostTax { get; set; } = true;
    public bool IncludeTraditional { get; set; } = true;
    public bool IncludeRoth { get; set; } = false;

    public decimal PostTaxGrowthPercent { get; set; } = 0m;
    public decimal TraditionalGrowthPercent { get; set; } = 0m;
    public decimal RothGrowthPercent { get; set; } = 0m;

    public AllocationModes AllocationMode { get; set; } = AllocationModes.Equal;
    public decimal PostTaxPct { get; set; } = 0m;
    public decimal TraditionalPct { get; set; } = 0m;
    public decimal RothPct { get; set; } = 0m;

    // Derived / results
    bool HasCalculated = false;
    int YearsUntilRetirement;
    int Months;
    int n;
    decimal MonthlyRate;

    List<BucketResult> BucketResults = new();

    decimal TotalInitialMonthly = 0m;

    public enum AllocationModes { Equal, Custom }

    class BucketResult
    {
        public string Name { get; set; } = "";
        public bool Included { get; set; }
        public decimal AllocationPercent { get; set; }
        public decimal AnnualGrowthPercent { get; set; }
        public decimal InitialMonthly { get; set; }
        public decimal ProjectedFV { get; set; }
    }

    // Yearly grid row combining all three buckets
    class YearlyGridRow
    {
        public int Year { get; set; }
        public int Age { get; set; }

        public decimal PostTaxPrincipal { get; set; }
        public decimal PostTaxGrowth { get; set; }
        public decimal PostTaxTaxes { get; set; }
        public decimal PostTaxPreTaxBalance { get; set; }
        public decimal PostTaxBalance { get; set; }

        public decimal TraditionalPrincipal { get; set; }
        public decimal TraditionalGrowth { get; set; }
        public decimal TraditionalTaxes { get; set; }
        public decimal TraditionalBalance { get; set; }

        public decimal RothPrincipal { get; set; }
        public decimal RothGrowth { get; set; }
        public decimal RothTaxes { get; set; }
        public decimal RothBalance { get; set; }

        public decimal TotalEndOfYear => PostTaxBalance + TraditionalBalance + RothBalance;
    }

    List<YearlyGridRow> YearlyGrid = new();

    // Tax assumptions used for taxable bucket (simple approximation)
    const decimal DEFAULT_ORDINARY_TAX = 0.24m;
    const decimal DEFAULT_LTG_TAX = 0.15m;
    // Default income distribution (MixedInvestment) used to split taxable interest
    readonly (decimal q, decimal nonq, decimal lt, decimal st) DEFAULT_INCOME_DISTRIBUTION = (0.25m, 0.25m, 0.40m, 0.10m);

    void Reset()
    {
        CurrentAge = 35;
        RetirementAge = 67;
        TargetAmount = 1000000m;
        AnnualReturnPercent = 6m;
        IncludePostTax = true;
        IncludeTraditional = true;
        IncludeRoth = false;
        PostTaxGrowthPercent = TraditionalGrowthPercent = RothGrowthPercent = 0m;
        AllocationMode = AllocationModes.Equal;
        PostTaxPct = TraditionalPct = RothPct = 0m;
        HasCalculated = false;
        BucketResults.Clear();
        TotalInitialMonthly = 0m;
        YearlyGrid.Clear();
    }

    private async Task Calculate()
    {
        try
        {
            HasCalculated = false;
            BucketResults.Clear();
            TotalInitialMonthly = 0m;
            YearlyGrid.Clear();

            if (RetirementAge <= CurrentAge || TargetAmount <= 0)
            {
                HasCalculated = true;
                return;
            }

            YearsUntilRetirement = RetirementAge - CurrentAge;
            Months = YearsUntilRetirement * 12;
            n = Months;
            MonthlyRate = (AnnualReturnPercent / 100m) / 12m;

            // identify included buckets
            var included = new List<string>();
            if (IncludePostTax) included.Add("Post‑tax");
            if (IncludeTraditional) included.Add("Traditional");
            if (IncludeRoth) included.Add("Roth");

            if (!included.Any())
            {
                HasCalculated = true;
                return;
            }

            // allocation percents
            var alloc = new Dictionary<string, decimal>();
            if (AllocationMode == AllocationModes.Equal)
            {
                var equal = 1m / included.Count;
                foreach (var k in included) alloc[k] = equal;
            }
            else
            {
                // custom: use provided percents but ignore unchecked buckets
                var sum = 0m;
                if (IncludePostTax) sum += PostTaxPct;
                if (IncludeTraditional) sum += TraditionalPct;
                if (IncludeRoth) sum += RothPct;
                if (sum <= 0) // fallback to equal
                {
                    var equal = 1m / included.Count;
                    foreach (var k in included) alloc[k] = equal;
                }
                else
                {
                    if (IncludePostTax) alloc["Post‑tax"] = PostTaxPct / sum;
                    if (IncludeTraditional) alloc["Traditional"] = TraditionalPct / sum;
                    if (IncludeRoth) alloc["Roth"] = RothPct / sum;
                }
            }

            // compute per bucket
            var buckets = new[]
            {
                new { Name = "Post‑tax", Included = IncludePostTax, AnnualGrowth = PostTaxGrowthPercent },
                new { Name = "Traditional", Included = IncludeTraditional, AnnualGrowth = TraditionalGrowthPercent },
                new { Name = "Roth", Included = IncludeRoth, AnnualGrowth = RothGrowthPercent }
            };

            foreach (var b in buckets)
            {
                var br = new BucketResult { Name = b.Name, Included = b.Included, AnnualGrowthPercent = b.AnnualGrowth / 100m };
                if (!b.Included)
                {
                    BucketResults.Add(br);
                    continue;
                }

                var allocPct = alloc.ContainsKey(b.Name) ? alloc[b.Name] : 0m;
                br.AllocationPercent = allocPct;
                var requiredFuture = TargetAmount * allocPct;

                // compute initial monthly PMT for growing annuity (payments at start of month)
                var gm = AnnualToMonthlyGrowth(b.AnnualGrowth / 100m);
                br.InitialMonthly = ComputeInitialMonthly(requiredFuture, MonthlyRate, gm, n);
                // compute projected FV to verify
                br.ProjectedFV = ComputeProjectedFVFromGrowingPayments(br.InitialMonthly, MonthlyRate, gm, n);

                TotalInitialMonthly += br.InitialMonthly;
                BucketResults.Add(br);
            }

            // Build yearly grid by simulating each bucket's payments and growth
            BuildYearlyGrid();

            HasCalculated = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Calculate error: {ex}");
        }
    }

    private void BuildYearlyGrid()
    {
        if (BucketResults == null || !BucketResults.Any()) return;

        // For each bucket prepare simulation state
        var post = BucketResults.FirstOrDefault(x => x.Name == "Post‑tax");
        var trad = BucketResults.FirstOrDefault(x => x.Name == "Traditional");
        var roth = BucketResults.FirstOrDefault(x => x.Name == "Roth");

        decimal postBal = 0m, tradBal = 0m, rothBal = 0m;
        decimal postPmt0 = post?.InitialMonthly ?? 0m;
        decimal tradPmt0 = trad?.InitialMonthly ?? 0m;
        decimal rothPmt0 = roth?.InitialMonthly ?? 0m;
        decimal postGm = AnnualToMonthlyGrowth((post?.AnnualGrowthPercent ?? 0m));
        decimal tradGm = AnnualToMonthlyGrowth((trad?.AnnualGrowthPercent ?? 0m));
        decimal rothGm = AnnualToMonthlyGrowth((roth?.AnnualGrowthPercent ?? 0m));

        int totalMonths = n;
        int monthIndex = 0; // 0-based

        for (int year = 1; year <= YearsUntilRetirement; year++)
        {
            var row = new YearlyGridRow { Year = year, Age = CurrentAge + year };
            decimal postYearPrincipal = 0m, postYearGrowth = 0m, postYearTaxes = 0m;
            decimal tradYearPrincipal = 0m, tradYearGrowth = 0m, tradYearTaxes = 0m;
            decimal rothYearPrincipal = 0m, rothYearGrowth = 0m, rothYearTaxes = 0m;

            for (int m = 1; m <= 12 && monthIndex < totalMonths; m++, monthIndex++)
            {
                int mAbs = monthIndex; // 0-based month count
                // payment grows by gm per month: pmt = pmt0 * (1+gm)^mAbs
                if (post != null && post.Included)
                {
                    var p = postPmt0 * DecimalPow(1m + postGm, mAbs);
                    postYearPrincipal += p;
                    // deposit at start of month
                    postBal += p;
                    // interest
                    var i = postBal * MonthlyRate;
                    postYearGrowth += i;
                    postBal += i;
                }

                if (trad != null && trad.Included)
                {
                    var p = tradPmt0 * DecimalPow(1m + tradGm, mAbs);
                    tradYearPrincipal += p;
                    tradBal += p;
                    var i = tradBal * MonthlyRate;
                    tradYearGrowth += i;
                    tradBal += i;
                }

                if (roth != null && roth.Included)
                {
                    var p = rothPmt0 * DecimalPow(1m + rothGm, mAbs);
                    rothYearPrincipal += p;
                    rothBal += p;
                    var i = rothBal * MonthlyRate;
                    rothYearGrowth += i;
                    rothBal += i;
                }
            }

            // capture pre-tax balance before taxes (even if zero)
            var postPreTaxBalance = postBal;
            // Taxes for taxable (post-tax) bucket - approximate using default distribution and tax rates
            if (post != null && post.Included)
            {
                var dist = DEFAULT_INCOME_DISTRIBUTION;
                var qual = postYearGrowth * dist.q;
                var nonq = postYearGrowth * dist.nonq;
                var lt = postYearGrowth * dist.lt;
                var st = postYearGrowth * dist.st;
                var taxes = qual * DEFAULT_LTG_TAX + (nonq + st) * DEFAULT_ORDINARY_TAX + lt * DEFAULT_LTG_TAX;
                postYearTaxes = taxes;
                postBal -= taxes;
            }

            // store pre-tax balance
            row.PostTaxPreTaxBalance = Math.Round(postPreTaxBalance, 2);

            // traditional and roth taxes assumed zero during accumulation

            row.PostTaxPrincipal = Math.Round(postYearPrincipal, 2);
            row.PostTaxGrowth = Math.Round(postYearGrowth, 2);
            row.PostTaxTaxes = Math.Round(postYearTaxes, 2);
            row.PostTaxBalance = Math.Round(postBal, 2);

            row.TraditionalPrincipal = Math.Round(tradYearPrincipal, 2);
            row.TraditionalGrowth = Math.Round(tradYearGrowth, 2);
            row.TraditionalTaxes = 0m;
            row.TraditionalBalance = Math.Round(tradBal, 2);

            row.RothPrincipal = Math.Round(rothYearPrincipal, 2);
            row.RothGrowth = Math.Round(rothYearGrowth, 2);
            row.RothTaxes = 0m;
            row.RothBalance = Math.Round(rothBal, 2);

            YearlyGrid.Add(row);
        }
    }

    private decimal GetFinalProjectedTotal()
    {
        var sum = BucketResults.Where(x => x.Included).Sum(x => x.ProjectedFV);
        if (sum == 0m && YearlyGrid.Any())
            return Math.Round(YearlyGrid.Last().TotalEndOfYear, 2);
        return Math.Round(sum, 2);
    }

    // convert annual growth rate to equivalent monthly growth
    private decimal AnnualToMonthlyGrowth(decimal annual)
    {
        if (annual == 0m) return 0m;
        var gm = (decimal)(Math.Pow((double)(1m + annual), 1.0 / 12.0) - 1.0);
        return gm;
    }

    // Compute initial monthly payment (month 1 payment) for an annuity-due with growth gm per month
    private decimal ComputeInitialMonthly(decimal futureTarget, decimal r, decimal gm, int periods)
    {
        if (periods <= 0) return 0m;

        const decimal EPS = 1e-12m;
        // handle special cases
        if (Math.Abs((double)(r - gm)) < 1e-12)
        {
            // r == gm
            var G = periods * (1m + r);
            return G <= 0 ? 0m : futureTarget / G;
        }

        // compute (1+r)^n and (1+gm)^n
        var onePlusRpowN = DecimalPow(1m + r, periods);
        var onePlusGmpowN = DecimalPow(1m + gm, periods);

        // G = [ (1+r)^n - (1+gm)^n ] / (r - gm) * (1+r)
        var denom = r - gm;
        // guard denom close to zero handled above
        var Gfactor = ((onePlusRpowN - onePlusGmpowN) / denom) * (1m + r);
        return Gfactor == 0m ? 0m : futureTarget / Gfactor;
    }

    // Compute projected future value produced by a growing payment stream starting with pmt0 (annuity due)
    private decimal ComputeProjectedFVFromGrowingPayments(decimal pmt0, decimal r, decimal gm, int periods)
    {
        if (periods <= 0) return 0m;
        if (pmt0 == 0m) return 0m;

        if (Math.Abs((double)(r - gm)) < 1e-12)
        {
            var G = periods * (1m + r);
            return pmt0 * G;
        }

        var onePlusRpowN = DecimalPow(1m + r, periods);
        var onePlusGmpowN = DecimalPow(1m + gm, periods);
        var denom = r - gm;
        var Gfactor = ((onePlusRpowN - onePlusGmpowN) / denom) * (1m + r);
        return pmt0 * Gfactor;
    }

    // Decimal power helper for integer exponent >= 0
    private decimal DecimalPow(decimal x, int pow)
    {
        if (pow == 0) return 1m;
        double dx = (double)x;
        double r = Math.Pow(dx, pow);
        return (decimal)r;
    }

    string FormatMoney(decimal v) => v.ToString("C0", CultureInfo.CurrentCulture);
}